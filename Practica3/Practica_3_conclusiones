Mi objetivo principal desde el inicio fue implementar un sistema de navegación robusto basado en Campos de Potencial Virtual (VFF), 
capaz de seguir un objetivo y evitar obstáculos activamente. El desarrollo fue un proceso iterativo, superando varios errores conceptuales.

Fase 1: Interpretación del Sensor y Primer Prototipo
El primer paso fue puramente instrumental: entender los datos del sensor láser. Antes de evitar obstáculos, necesitaba "verlos". 
La primera versión del código se centró en una función parse_laser_data que no solo leía los 180 valores, 
sino que los convertía de distancias y ángulos a coordenadas X/Y relativas al robot. Esto fue fundamental para cualquier cálculo posterior.

Con esta base, implementé la lógica básica de VFF: una función para el vector de atracción al objetivo y otra para el vector de repulsión de los obstáculos. 
Aquí surgió el primer gran problema conceptual: mezclaba sistemas de coordenadas.

El vector de atracción se calculaba en coordenadas absolutas (posición del robot y del objetivo en el mundo).

El vector de repulsión se calculaba en coordenadas relativas (basado en los (x, y) del láser).

Al intentar sumar estos dos vectores, el resultado era matemáticamente incorrecto y no tenía sentido físico. 
El control, además, solo usaba la repulsión, por lo que el robot se limitaba a huir de las paredes, ignorando el objetivo. 
Aunque en una iteración posterior (tercer código) usé numpy y visualicé las fuerzas, esto solo sirvió para confirmar gráficamente el error de base.

Fase 2: Corrección de Coordenadas y Errores de Control
La solución (cuarto código) fue realizar todos los cálculos en el marco de referencia relativo al robot. 
La mejora clave fue en obtener_vector_objetivo, donde usé la orientación del robot (el yaw) para rotar el vector de atracción absoluto y convertirlo en uno relativo.

Ahora sí, tanto la atracción como la repulsión estaban en el mismo sistema y la suma ponderada total = atractivo * 0.8 + repulsion * 0.2 era coherente. 
Sin embargo, el control seguía fallando. Aunque el vector total era correcto, la velocidad angular w se seguía basando solo en la componente lateral de la repulsión. 
El robot esquivaba, pero ignoraba la dirección del vector total para girar.

Decidí (quinto código) usar ese vector total para controlar el giro, introduciendo un controlador PID para la velocidad angular w. 
La lógica era calcular el ángulo deseado (desired_angle = math.atan2(total[1], total[0])) y usar el PID para alcanzarlo.

Esto me llevó a un nuevo error conceptual. El error del PID se calculó como error = desired_angle - robot_angle. Volví a mezclar sistemas: desired_angle es relativo al morro del robot, 
pero robot_angle (el yaw) es absoluto en el mundo. El control, de nuevo, era incorrecto.

Fase 3: La Lógica de Control Correcta
La solución (sexto código) fue comprender que el desired_angle (atan2(total_rel[1], total_rel[0])) no era un objetivo, 
sino que ya era la señal de error que el robot debía corregir. Un ángulo 0 significaba "recto", un ángulo positivo significaba "gira a la izquierda".

Implementando error = math.atan2(total_rel[1], total_rel[0]) en el PID (o simplemente usándolo proporcionalmente) el sistema funcionó.
El robot navegaba, esquivaba y, con la gestión de tolerancia, se detenía en el objetivo.

Fase 4: Optimización y Arquitectura Híbrida Final
Aunque funcional, el control de velocidad lineal v y angular w se sentía demasiado "acoplado". 
Probé (séptimo y octavo código) con enfoques de control proporcional más directos, usando el vector total para definir ambas velocidades e incluso normalizando los vectores. 
Estos métodos funcionaban, pero eran muy sensibles a los pesos y un obstáculo podía afectar tanto al giro como a la velocidad de avance de forma indeseada.

Esto me llevó al rediseño final (noveno código): una arquitectura híbrida desacoplada, que resultó ser la solución más robusta.

Implementé dos sistemas de control independientes:

Control Angular (VFF): La velocidad angular w pasó a depender únicamente de la suma de las fuerzas laterales (steering_force = T_y + O_y). Su único trabajo es decidir la dirección (esquivar y buscar).

Control Lineal (PID): La velocidad lineal v se asignó a un PID independiente, cuyo único trabajo es mantener una distancia de seguridad (ej. PID_SETPOINT_DIST = 1.5m) con lo que tenga delante. Si el camino está libre, va a MAX_LINEAR_SPEED; si algo se acerca, frena.

Este desacoplamiento fue el salto cualitativo. El módulo de giro (VFF) se concentra en la dirección, mientras que el módulo de velocidad (PID) actúa como un control adaptativo de seguridad.

De esta forma, y tras corregir varios errores conceptuales (coordenadas y lógica del PID), conseguí un robot que calcula todas las fuerzas en su marco relativo, usa VFF para un control de giro desacoplado y un PID de seguridad para controlar la velocidad lineal.
